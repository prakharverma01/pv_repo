'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getFrequencyOfUniqueValues = getFrequencyOfUniqueValues;
exports.uniqueGeneric = uniqueGeneric;
exports.uniqueRanges = uniqueRanges;
exports.uniqueObject = uniqueObject;
exports.buildOptionsList = buildOptionsList;

var _flattenRecursive2 = require('./flattenRecursive.js');

var _flattenRecursive3 = _interopRequireDefault(_flattenRecursive2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function saveFn(attribute, key, fn) {
    return _defineProperty({}, attribute + '__' + key, fn);
}

function accumulate(collection, value) {
    if (!collection[value]) {
        collection[value] = 0;
    }
    collection[value]++;
    return collection;
}

function getFrequencyOfUniqueValues(attribute, items) {
    return valueMap(attribute, items, function (prev, currentVal) {
        if (currentVal === undefined) return prev;

        if (currentVal instanceof Array) {
            currentVal.forEach(function (val) {
                prev = accumulate(prev, val);
            });
        } else {
            prev = accumulate(prev, currentVal);
        }
        return prev;
    });
}

function valueMap(attribute, items, fn) {
    return items.reduce(function (prev, currentItem) {
        return fn(prev, currentItem[attribute]);
    }, {});
}

function uniqueGeneric(configValue, items) {
    var keySortFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var title = configValue.title,
        attribute = configValue.attribute;

    var options = getFrequencyOfUniqueValues(attribute, items);
    var filterFns = Object.keys(options).reduce(function (acc, key) {
        var fn = function fn(item) {
            if (item[attribute] instanceof Array) {
                return item[attribute].indexOf(key) > -1;
            }
            return item[attribute] === key;
        };
        return _extends({}, acc, saveFn(attribute, key, fn));
    }, {});

    var keys = Object.keys(options);
    // keys might have a sort function
    if (typeof keySortFn === 'function') {
        keys = keySortFn(keys);
    }

    return {
        filterFns: filterFns,
        values: {
            title: title,
            values: keys.map(function (key) {
                return { value: key, count: options[key], attribute: attribute };
            })
        }
    };
}

function buildRangeFn(min, max, attribute) {
    return function (item) {
        return item[attribute] >= min && item[attribute] <= max;
    };
}

function find(arr, fn) {
    for (var i = 0, len = arr.length; i < len; i++) {

        if (fn(arr[i])) {
            return arr[i];
        }
    }
}

function within(min, max, num) {
    return num >= min && num <= max;
}

function uniqueRanges(configValue, items) {
    var sortFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var title = configValue.title,
        attribute = configValue.attribute,
        ranges = configValue.ranges;

    var filterFns = {};

    var options = valueMap(attribute, items, function (prev, currentValue) {
        // find which range i falls in
        var foundRange = find(ranges, function (rangeObj) {
            var _rangeObj$range = rangeObj.range,
                min = _rangeObj$range.min,
                max = _rangeObj$range.max;

            return within(min, max, currentValue);
        });

        // if we did not find a range that matches, bail
        if (!foundRange) {
            return prev;
        }

        var _foundRange$range = foundRange.range,
            min = _foundRange$range.min,
            max = _foundRange$range.max;
        // build range fn

        filterFns = _extends({}, filterFns, saveFn(attribute, foundRange.displayValue, buildRangeFn(min, max, attribute)));

        accumulate(prev, foundRange.displayValue);
        return prev;
    });

    var keys = Object.keys(options);
    if (typeof sortFn === 'function') {
        keys = sortFn(keys);
    }

    return {
        filterFns: filterFns,
        values: {
            title: title,
            values: keys.map(function (key) {
                return { count: options[key], attribute: attribute, value: key };
            })
        }
    };
}

function uniqueObject(configValue, items, sortFn) {
    var attribute = configValue.attribute,
        title = configValue.title,
        id = configValue.id,
        _configValue$attribut = configValue.attributeDisplayValue,
        attributeDisplayValue = _configValue$attribut === undefined ? 'title' : _configValue$attribut;

    var _flattenRecursive = (0, _flattenRecursive3.default)(attribute, items, id, saveFn, attributeDisplayValue),
        values = _flattenRecursive.values,
        filterFns = _flattenRecursive.filterFns;

    if (typeof sortFn === 'function') {

        values = (0, _flattenRecursive2.recurseLevel)(values, 'children', sortFn);
    }

    return {
        filterFns: filterFns,
        values: {
            title: title,
            values: values
        }
    };
}

function getUniqueValues(configValue, items, sortFn) {
    if (configValue.ranges) {
        return uniqueRanges(configValue, items, sortFn);
    }
    if (configValue.hierarchy) {
        return uniqueObject(configValue, items, sortFn);
    }
    return uniqueGeneric(configValue, items, sortFn);
}

function buildOptionsList(items, criteria, sortOptions) {

    return criteria.reduce(function (acc, crit) {
        var _getUniqueValues = getUniqueValues(crit, items, sortOptions[crit.attribute]),
            values = _getUniqueValues.values,
            filterFns = _getUniqueValues.filterFns;

        return {
            optionGroups: (acc.optionGroups || []).concat(values),
            filterFns: _extends({}, acc.filterFns, filterFns)
        };
    }, {});
}