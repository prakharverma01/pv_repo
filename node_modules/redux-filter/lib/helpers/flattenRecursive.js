'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.recurseLevel = recurseLevel;
exports.default = flattenDedup;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function recurse(arr, fn) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var hierarchicalCategory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    // some items might not have the attribute we're building
    if (!arr) return;

    for (var i = 0, len = arr.length; i < len; i++) {
        var item = arr[i];
        fn(item, parent, hierarchicalCategory);
        // find any value that is nested
        for (var prop in item) {
            if (item.hasOwnProperty(prop)) {
                // check if this is array/object
                if (_typeof(item[prop]) === 'object') {
                    recurse(item[prop], fn, item, prop);
                }
            }
        }
    }
}

function recurseLevel(arr, childAttribute, fn) {
    arr = fn(arr);

    for (var i = 0, len = arr.length; i < len; i++) {
        var item = arr[i];
        if (item[childAttribute]) {
            recurseLevel(item[childAttribute], childAttribute, fn);
        }
    }
    return arr;
}

function objectInArray(arr, fn) {
    for (var i = 0, len = arr.length; i < len; i++) {
        if (fn(arr[i])) {
            return true;
        }
    }
    return false;
}

function find(arr, childAttribute, fn) {
    var result = void 0;
    for (var i = 0, len = arr.length; i < len; i++) {
        var item = arr[i];
        // check if this passes
        if (fn(item)) {
            return item;
        }
        if (item[childAttribute]) {
            // otherwise rescurse
            result = find(item[childAttribute], childAttribute, fn);
            if (result) {
                return result;
            }
        }
    }
    return false;
}

function flattenDedup(attribute, subjects, idField, saveFn) {
    var displayProperty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'title';


    var tree = [];
    var seenKeys = {};
    var filterFns = {};

    subjects.forEach(function (subject) {
        recurse(subject[attribute], function (item, parent, hierarchicalCategory) {

            seenKeys[item[displayProperty]] = item[idField];

            var parentArray = void 0;
            if (parent === null) {
                parentArray = tree;
            } else {
                // find parent node
                var parentNode = find(tree, hierarchicalCategory, function (i) {
                    return i[idField] == parent[idField];
                });
                if (!parentNode[hierarchicalCategory]) {
                    parentNode[hierarchicalCategory] = [];
                }
                parentArray = parentNode[hierarchicalCategory];
            }

            // check if item already in parent
            if (!objectInArray(parentArray, function (i) {
                return i[idField] == item[idField];
            })) {
                var _extends2;

                var attributeKey = parent ? parent[idField] + '-' + item[idField] : item[idField];

                // add an entry it
                parentArray.push(_extends({}, copyShallow(item), (_extends2 = {}, _defineProperty(_extends2, idField, item[idField]), _defineProperty(_extends2, 'value', item[displayProperty]), _defineProperty(_extends2, 'count', 1), _defineProperty(_extends2, 'attribute', attributeKey), _extends2)));

                var filterFn = function filterFn(subject) {
                    // find the content id
                    return find(subject[attribute], hierarchicalCategory, function (attr) {
                        return attr[idField] === item[idField];
                    });
                };

                filterFns = _extends({}, filterFns, saveFn(attributeKey, item[displayProperty], filterFn));
            } else {
                // find and increment it
                var node = find(parentArray, hierarchicalCategory, function (i) {
                    return i[idField] == item[idField];
                });
                node.count++;
            }
        });
    });

    // check to make sure we don't have items with the same key
    var seen = {};
    for (var prop in seenKeys) {
        if (seenKeys.hasOwnProperty(prop)) {
            if (seen[seenKeys[prop]]) {
                throw new Error('keys on filter attributes must be unique');
            }
            seen[seenKeys[prop]] = true;
        }
    }

    return {
        values: tree,
        filterFns: filterFns
    };
}

function copyShallow(obj) {
    var result = {};
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop) && !(_typeof(obj[prop]) == 'object')) {
            result[prop] = obj[prop];
        }
    }
    return result;
}